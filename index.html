<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Citation</title>
  <meta http-equiv="Cache-Control" content="no-store, max-age=0" />
  <style>
    :root{
      --bg: #f8f4e6;     /* beige papier */
      --ink:#002fa7;     /* Bleu Klein */
      --pad: clamp(16px, 5vw, 36px);
      --boxw: min(900px, 94vw);
      --radius: 12px;
    }
    html, body {
      margin: 0; padding: 0; min-height: 100vh;
      background: var(--bg); color: var(--ink);
      font-family: "Courier New", monospace;
    }
    body {
      padding:
        calc(env(safe-area-inset-top, 0px))
        calc(env(safe-area-inset-right, 0px))
        calc(env(safe-area-inset-bottom, 0px))
        calc(env(safe-area-inset-left, 0px));
      display: grid; place-items: center;
    }
    .card {
      width: var(--boxw);
      max-width: var(--boxw);
      max-height: calc(100vh - 8vh);
      padding: var(--pad);
      background: rgba(255,255,255,.85);
      border: 1px solid #e0d8c3;
      border-radius: var(--radius);
      box-shadow: 0 8px 28px rgba(0,0,0,.08);
      display: grid; place-items: center;
      overflow: hidden;
    }
    #quote {
      text-align: center;
      line-height: 1.6;
      word-break: break-word;
      overflow-wrap: anywhere;
      hyphens: auto;
      white-space: pre-line; /* conserve les retours chariot du .txt */
    }
  </style>
</head>
<body>
  <div class="card">
    <div id="quote">Chargement…</div>
  </div>

  <script>
    /* ---------- Config ---------- */
    const GDOC_URL    = "https://docs.google.com/document/d/1cao2dKO5laTNxQTxIcGyI7inl2vLsr4ehei8ZqlalVk/export?format=txt";
    const STORAGE_KEY = "citation_unique_preserve_newlines_slash";
    const SEPARATOR   = "///";        // séparateur entre citations

    /* ---------- Utilitaires ---------- */
    const pickRandom = arr => arr[Math.floor(Math.random() * arr.length)];
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

    async function fetchDocText(){
      const res  = await fetch(GDOC_URL, { cache: "no-store", credentials: "omit" });
      const text = await res.text();
      // On garde les vrais \n
      return text
        .replace(/\u00A0/g, " ")        // nbsp → espace
        .replace(/[ \t\f\v]{2,}/g, " ") // compresse espaces multiples
        .trim();
    }

    // taille cible en fonction de la longueur
    const GLOBAL_MIN_PX = 12, GLOBAL_MAX_PX = 34;
    const LEN_MIN = 60, LEN_MAX = 320;
    const SIZE_AT_LEN_MIN = 30, SIZE_AT_LEN_MAX = 14;

    function computeTargetSizePx(text){
      const len = text.length;
      const t = clamp((len - LEN_MIN) / (LEN_MAX - LEN_MIN), 0, 1);
      const interp = SIZE_AT_LEN_MIN + (SIZE_AT_LEN_MAX - SIZE_AT_LEN_MIN) * t;
      return clamp(interp, GLOBAL_MIN_PX, GLOBAL_MAX_PX);
    }

    function fitTextToContainer(el, container, {minPx, maxPx, step=0.5}){
      let lo = minPx, hi = maxPx, best = minPx;
      const fits = (px) => {
        el.style.fontSize = px + "px";
        return el.scrollHeight <= container.clientHeight && el.scrollWidth <= container.clientWidth;
      };
      for (let i = 0; i < 20; i++) {
        const mid = Math.round((lo + hi) / 2 / step) * step;
        if (mid === lo || mid === hi) break;
        if (fits(mid)) { best = mid; lo = mid; } else { hi = mid; }
      }
      while (!(el.scrollHeight <= container.clientHeight && el.scrollWidth <= container.clientWidth) && best > minPx){
        best = Math.max(minPx, best - step);
        el.style.fontSize = best + "px";
      }
      el.style.fontSize = Math.max(minPx, best - 0.5) + "px";
    }

    function scheduleFit(bounds){
      clearTimeout(scheduleFit._t);
      scheduleFit._t = setTimeout(() => {
        requestAnimationFrame(() => {
          const card = document.querySelector(".card");
          const quote = document.getElementById("quote");
          if (!quote.textContent) return;
          fitTextToContainer(quote, card, bounds);
        });
      }, 30);
    }

    /* ---------- Init ---------- */
    async function init(){
      try{
        const el = document.getElementById('quote');

        // Même citation au refresh (par onglet)
        const cached = sessionStorage.getItem(STORAGE_KEY);
        if (cached) {
          el.textContent = cached;
          const target = computeTargetSizePx(el.textContent);
          const bounds = {minPx: target-6, maxPx: target+4};
          scheduleFit(bounds);
          return;
        }

        const all = await fetchDocText();
        const parts = all.split(/\s*\/\/\/\s*/g).map(s => s.trim()).filter(Boolean);
        if (!parts.length) throw new Error("Aucune citation détectée (séparateur /// manquant).");

        const picked = pickRandom(parts);
        sessionStorage.setItem(STORAGE_KEY, picked);

        el.textContent = picked;
        const target = computeTargetSizePx(picked);
        const bounds = {minPx: target-6, maxPx: target+4};
        scheduleFit(bounds);

        const onResize = () => scheduleFit(bounds);
        window.addEventListener('resize', onResize, {passive:true});
        window.addEventListener('orientationchange', onResize, {passive:true});
        try { new ResizeObserver(onResize).observe(document.querySelector('.card')); } catch(_) {}
        document.fonts?.ready?.then(() => scheduleFit(bounds));
      }catch(e){
        document.getElementById('quote').textContent =
          "Impossible de charger les citations.\n" + (e?.message || e);
      }
    }

    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
